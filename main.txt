package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

func Hex(arg string) int {
	value := arg
	result, err := strconv.ParseInt(value, 16, 64)
	if err != nil {
		return -1
	}
	return int(result)
}

func Bin(arg string) int {
	value := arg
	result, err := strconv.ParseInt(value, 2, 64)
	if err != nil {
		return -1
	}
	return int(result)
}

func Cap(s string) string {
	runes := []rune(s)
	isNewWord := true

	for i := 0; i < len(runes); i++ {
		if (runes[i] >= 'A' && runes[i] <= 'Z') || (runes[i] >= 'a' && runes[i] <= 'z') || (runes[i] >= '0' && runes[i] <= '9') {
			if isNewWord {
				if runes[i] >= 'a' && runes[i] <= 'z' {
					runes[i] = runes[i] - 'a' + 'A'
				}
				isNewWord = false
			} else {
				if runes[i] >= 'A' && runes[i] <= 'Z' {
					runes[i] = runes[i] - 'A' + 'a'
				}
			}
		} else {
			isNewWord = true
		}
	}
	return string(runes)
}

func Low(s string) string {
	var result string
	for _, r := range s {
		if r >= 'A' && r <= 'Z' {
			r = r + 32
		}
		result += string(r)
	}
	return result
}

func Up(s string) string {
	var result string
	for _, r := range s {
		if r >= 'a' && r <= 'z' {
			r = r - 32
		}
		result = result + string(r)
	}
	return result
}

func AutoCorrect(words []string) []string {
	for i := 0; i < len(words); i++ {
		r := words[i]
		if r == "(hex)" && i > 0 {

			decimal := Hex(words[i-1])
			if decimal != -1 {
				words[i-1] = strconv.Itoa(decimal)
			}
			words[i] = ""
			i = 0
		}

		if r == "(bin)" && i > 0 {
			decimal := Bin(words[i-1])
			if decimal != -1 {
				words[i-1] = strconv.Itoa(decimal)
			}
			words[i] = ""
			i = 0

		}

		if r == "(cap)" && i > 0 {
			words[i-1] = Cap(words[i-1])
			words[i] = ""
			i = 0
		}

		if r == "(cap," {
			valueStr := words[i+1]
			valueInt, _ := strconv.Atoi(valueStr[:len(valueStr)-1])

			for j := i - 1; j >= i-valueInt; j-- {
				words[j] = Cap(words[j])
			}

			words[i] = ""
			words[i+1] = ""
			i = 0
		}

		if r == "(low)" && i > 0 {
			words[i-1] = Low(words[i-1])
			words[i] = ""
			i = 0
		}

		if r == "(low," {
			valueStr := words[i+1]
			valueInt, _ := strconv.Atoi(valueStr[:len(valueStr)-1])

			for j := i - 1; j >= i-valueInt; j-- {
				words[j] = Low(words[j])
			}

			words[i] = ""
			words[i+1] = ""
			i = 0
		}

		if r == "(up)" && i > 0 {
			
			words[i-1] = Up(words[i-1])
			words[i] = ""
			i = 0
		}

		if r == "(up," {
			valueStr := words[i+1]
			valueInt, _ := strconv.Atoi(valueStr[:len(valueStr)-1])

			for j := i - 1; j >= i-valueInt; j-- {
				words[j] = Up(words[j])
			}

			words[i] = ""
			words[i+1] = ""
			i = 0
		}

	}

	return words
}
func Clean(words []string) []string {
	wordsClean := []string{}
	for _, r := range words {

		if r != "" {
			wordsClean = append(wordsClean, r)
		}
	}
	return wordsClean
}

func AtoAn(words []string) []string {
	for i, r := range words {
		if i+1 < len(words) {
			if (r == "a" || r == "A") && (strings.HasPrefix(Low(words[i+1]), "a") || strings.HasPrefix(Low(words[i+1]), "e") || strings.HasPrefix(Low(words[i+1]), "i") || strings.HasPrefix(Low(words[i+1]), "o") || strings.HasPrefix(Low(words[i+1]), "u") || strings.HasPrefix(Low(words[i+1]), "h")) {
				words[i] = words[i] + "n"
			}
		}
	}
	return words
}
func FixQuotes(lines []string) [][]string {
	words := []string{}
	//temp := []string{}
	result := [][]string{}
	first := true
	str := ""
	for _, r := range lines {
		str = ""
		for _, k := range r {

			if k == '.' || k == ',' || k == '!' || k == '?' || k == ':' || k == ';' {
				str += string(k) + " "
			}else if k == '\''{
				str += " "+string(k)+" "
			} else {
				str += string(k)
			}

		}

		words = strings.Split(str, " ")
		words = Clean(words)
		fmt.Println(words)
		/*for i, k := range words {

			if strings.HasPrefix(k, "'") && !strings.HasSuffix(k, "'") {
				temp = append(temp, "'")
				temp = append(temp, words[i][1:])
			} else if strings.HasSuffix(k, "'") && !strings.HasPrefix(k, "'") {
				temp = append(temp, words[i][:len(k)-1])
				temp = append(temp, "'")

			} else {
				temp = append(temp, k)

			}
		}*/
		for i := 0; i < len(words); i++ {
			r := words[i]
			if r == "'" && first && i+1<len(words) && words[i+1] != "'" {
				words[i+1] = "'" + words[i+1]
				words[i] = ""
				first = false
			} else if r == "'" && !first && words[i-1] != "'"  {
				words[i-1] = words[i-1] + "'"
				words[i] = ""
				first = true
			}

		}
		first = true
		//words = temp

		for i := 0; i < len(words); i++ {

			r := words[i]
			if r == "." || r == "," || r == "!" || r == "?" || r == ":" || r == ";" {
				words[i-1] = words[i-1] + r
				words[i] = ""
				wordsF := []string{}
				for _, r := range words {
					if r != "" {
						wordsF = append(wordsF, r)
					}
				}
				words = wordsF
				i = 0
			}
			AutoCorrect(words)

		}
		//temp = []string{}
		words = AtoAn(words)
		result = append(result, words)
	}
	return result

}

func main() {
	content, _ := os.ReadFile("input.txt")
	lines := strings.Split(string(content), "\n")
	result := FixQuotes(lines)
	resultF := ""

	for i, r := range result {
		for _, k := range Clean(r) {
			resultF += k + " "
		}
		if i < len(result)-1 {
			resultF += "\n"
		}
	}

	fmt.Print(resultF)

}
